<!-- src/pages/minimal-blog.astro -->
<!--
    This Astro page serves as the entry point for the "Minimal Blog Experience".
    It fetches blog posts from the Astro Content Collection and passes them
    as props to the React Terminal component.
    This ensures content is decoupled and reusable.
    Updated: Now uses 'marked' to render Markdown to HTML, with 'marked' configured
    to explicitly *disable* its own syntax highlighting. This ensures that
    highlighting is solely handled by the Terminal.tsx component, preventing double rendering.
    It also ensures fixed width per line in code blocks based on max line length.
-->
---
// Import the Terminal React component.
import Terminal from '../components/Terminal.tsx';

// Import Astro's content collection utilities and the CollectionEntry type
import { getCollection, type CollectionEntry } from 'astro:content';

// Import the 'marked' library for Markdown to HTML conversion.
import { marked } from 'marked';

// Configure marked to NOT perform syntax highlighting.
// This is crucial so that your Terminal.tsx component's highlightCode function
// is the sole source of syntax highlighting.
marked.setOptions({
  highlight: function(code, lang) {
    // By returning the code as-is, we prevent marked from adding its own <span> tags.
    return code;
  },
  gfm: true, // Enable GitHub Flavored Markdown for standard parsing
});

// Define the BlogPost type based on your schema (should match src/components/Terminal.tsx)
interface BlogPostContent {
  slug: string;
  title: string;
  author: string;
  date: string; // Already formatted as INSEE-MM-DD
  summary: string; // Short description for list view
  content: string[]; // Parsed paragraphs
  codeBlocks?: { language: string; code: string; }[]; // Structured for code blocks
}

// Fetch all blog posts from the 'blogs' content collection.
const allBlogEntries: CollectionEntry<'blogs'>[] = await getCollection('blogs');

// Preprocess the blog entries to extract plain text content and code blocks.
const blogPosts: BlogPostContent[] = await Promise.all(
  allBlogEntries.map(async (entry) => {
    // Use 'marked' to convert the raw Markdown body (entry.body) to HTML.
    // Due to marked.setOptions, this HTML will *not* have internal syntax highlighting spans.
    let rawHtml = await marked(entry.body);

    // --- HTML Cleanup (optional, but good for robustness against unexpected HTML) ---
    // Remove any extraneous tags like scripts or styles that might be injected.
    rawHtml = rawHtml
      .replace(/<!--[\s\S]*?-->/g, '') // Remove HTML comments
      .replace(/<script[\s\S]*?<\/script>/g, '') // Remove script tags
      .replace(/<style[\s\S]*?<\/style>/g, ''); // Remove style tags

    // --- Extracting Code Blocks ---
    // This regex looks for <pre><code class="language-xyz">...</code></pre> blocks.
    // It captures the language and the raw code content within the <code> tags.
    const codeBlockRegex = /<pre><code class="language-(\w+)">([\s\S]*?)<\/code><\/pre>/g;
    const extractedCodeBlocks: { language: string; code: string; }[] = [];
    let match;

    // Create a copy of rawHtml to progressively remove code blocks for plain text processing
    let htmlForPlainText = rawHtml;

    // Iterate through all code blocks found in the HTML.
    while ((match = codeBlockRegex.exec(rawHtml)) !== null) {
      const language = match[1];
      let code = match[2]; // This 'code' should now be raw, without highlight spans from marked.

      // Decode HTML entities (e.g., &lt; becomes <, &amp; becomes &)
      code = code.replace(/&amp;/g, '&')
                 .replace(/&lt;/g, '<')
                 .replace(/&gt;/g, '>')
                 .replace(/&quot;/g, '"')
                 .replace(/&#39;/g, "'")
                 .trim(); // Trim any leading/trailing whitespace

      extractedCodeBlocks.push({ language, code });

      // Remove the *original* matched code block from `htmlForPlainText`
      // so it's not included in the plain text content.
      htmlForPlainText = htmlForPlainText.replace(match[0], '');
    }

    // --- Extracting Plain Text Content ---
    // Now, strip all remaining HTML tags from the modified HTML string
    // (which no longer contains code blocks) to get the pure plain text content.
    const plainTextRaw = htmlForPlainText
      .replace(/<[^>]+>/g, '')    // Remove all other HTML tags (like <p>, <h1>, <ul>, <li>, etc.)
      .trim(); // Trim leading/trailing whitespace from the entire block

    // Split into lines, trim each line, and filter out any entirely empty lines.
    const plainTextContent = plainTextRaw
      .split('\n')
      .map((line: string) => line.trim())
      .filter((line: string) => line.length > 0);

    return {
      slug: entry.slug,
      title: entry.data.title,
      author: entry.data.author,
      date: entry.data.date.toISOString().split('T')[0], // Format date as YYYY-MM-DD
      summary: entry.data.summary,
      content: plainTextContent,
      codeBlocks: extractedCodeBlocks.length > 0 ? extractedCodeBlocks : undefined,
    };
  })
);
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlogLabs - Minimal TUI</title>
    <!-- Favicon link -->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="stylesheet" href="src/style/minimal-blog.css">
</head>
<body>
    <!--
        The Astro.js component that renders our React Terminal application.
        The `client:load` directive ensures that the React component
        is hydrated and interactive on the client-side as soon as possible.
        This is crucial for handling keyboard events and managing dynamic UI.
    -->
    <Terminal client:load blogPosts={blogPosts} />
</body>
</html>
